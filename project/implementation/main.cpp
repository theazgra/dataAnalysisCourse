#include "external/args.hxx"
#include "network_matrix.h"

/*
    NetworkMatrix is always indexed from zero!!!
    - If imported network vertex begin at one instead of zero use offset of -1 in NetworkMatrix::load_from_edges() function.

    Network can be either imported or generated.
    Two network types can be generated. Random ( generate_random_network() ) or Barabasi-Albert model ( generate_scale_free_network ).
*/
int main(int argc, char **argv)
{
    args::ArgumentParser parser("Network analysis. - MOR0146", "Required arguments are in < > optional in [].");
    args::Group methodGroup(parser, "Methods", args::Group::Validators::AtMostOne);
    args::HelpFlag _help(methodGroup, "help", "Print help", {'h', "help"});

    args::Flag _import(methodGroup, "import", "Import network from csv file (';' as delimiter) and run analysis. <file> <report-file>", {'i', "import"});
    args::Flag _generate(methodGroup, "generate", "Generate and save network. <vertex-count> <network-file> <report-file> [probability]",
                         {'g', "generate"});

    args::Flag _demo(methodGroup, "demo", "Generate and analyse Network model generated by Barabasi-Albert model.", {'d', "demo"});

    args::ValueFlag<std::string> _file(parser, "file", "CSV file.", {'f', "file"});
    args::ValueFlag<std::string> _reportFile(parser, "report-file", "Report text file.", {'r', "report"});
    args::ValueFlag<uint> _vertexCount(parser, "vertex-count", "Vertex count.", {'v', "vertex-count"});
    args::ValueFlag<float> _prob(parser, "probability.", "Edge probability.", {'p', "edge-probability"});
    args::ValueFlag<uint> _baM(parser, "m", "Number of connections in B-A method", {'m'});

    args::Flag _baMethod(parser, "BA", "Use Barabasi-Albert model for generating..", {"ba"});

    try
    {
        parser.ParseCLI(argc, argv);
    }
    catch (args::Help)
    {
        std::cout << parser;
        return 0;
    }
    catch (args::ParseError e)
    {
        std::cerr << e.what() << std::endl;
        std::cerr << parser;
        return 1;
    }

    if (_import)
    {

        auto loadedEdges = load_edge_pairs(_file.Get().c_str(), ";");
        uint vc = get_vertex_count_from_edge_pairs(loadedEdges);
        NetworkMatrix network = NetworkMatrix(vc, vc);
        network.load_from_edges(loadedEdges);
        printf("Loaded network from %s.\n", _file.Get().c_str());
        network.complete_analysis("Imported", _reportFile.Get().c_str());
        printf("Completed analysis in %s\n", _reportFile.Get().c_str());
        return 0;
    }

    if (_generate)
    {
        uint vertexCount = _vertexCount.Get();
        NetworkMatrix nm(vertexCount, vertexCount);

        if (_baMethod)
        {
            nm.generate_scale_free_network((_baM ? _baM.Get() : 2), vertexCount - 3);
            printf("Generated network using Barabasi-Albert method.\n");
            nm.export_network(_file.Get().c_str());
            printf("Saved network in: %s\n", _file.Get().c_str());
            nm.complete_analysis("Generated using Barabasi-Albert method.", _reportFile.Get().c_str(), true, true);
            printf("Completed analysis in %s\n", _reportFile.Get().c_str());
            return 0;
        }
        else
        {
            nm.generate_random_network(_prob ? _prob.Get() : 0, !((bool)_prob));
            printf("Generated network using random method, edge probability=%f.\n", _prob.Get());
            nm.export_network(_file.Get().c_str());
            printf("Saved network in: %s\n", _file.Get().c_str());
            printf("Random network doesn't support full analysis because the network may not be symmetric.\n");
            nm.complete_analysis("Generated using Barabasi-Albert method.", _reportFile.Get().c_str(), true, false);
            printf("Completed analysis in %s\n", _reportFile.Get().c_str());
            return 0;
        }
    }

    if (_demo)
    {
        // PROJECT
        const uint vertexCount = 1000;
        const uint m = 2;
        const char *exportNetworkFile = "../out/scaleFreeNet.csv";
        const char *reportFile = "../out/scaleFreeReport.txt";

        // 1. Scale free network generation, exporting to exportNetworkFile.
        NetworkMatrix network(vertexCount, vertexCount);
        // We are starting with 3 vertices.

        network.generate_scale_free_network(m, (vertexCount - 3));
        network.export_network(exportNetworkFile);

        // 2. Network Analysis
        network.complete_analysis("ScaleFreeNetwork", reportFile);
        return 0;
    }

    std::cout << parser;
    return 1;
}
